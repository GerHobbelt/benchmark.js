{
  title: 'test #11 : large `switch`/`case` vs. other ways to dispatch',
  description: 'Does a very large `switch`/`case` statement negatively impact performance vs. `if`/`elseif` or subdividing the `switch`/`case` into a double layer of `switch`/`case`?',
  related: [
  ],

  HTML: "",
  init: "\
      // simply injecting script tag to DOM via innerHTML doesn't work, so we have to do it this way:\n\
      [\n\
      ].forEach(function (src) {\n\
        var script = document.createElement('script');\n\
        script.src = src;\n\
        document.head.appendChild(script);\n\
      });\n\
\n\
      var dataX = [];\n\
      var data = [];\n\
      var data_length = 0;\n\
\n\
      var glob = 0;\n\
\n\
      // test functions; generated by init():\n\
      var switch_case;\n\
      var if_elif;\n\
      var dual_layer_switch_case;\n\
      var jump_table;\n\
      var jump_table2;\n\
\n\
      function init() {\n\
        if (data_length) return;\n\
\n\
        // use random generator to help generate the test code so that it cannot be\n\
        // easily simplified by common code reduction, etc.\n\
\n\
        var L = 0x20; // 0x10;\n\
        var M = 0x18; // 0x0C;\n\
\n\
        for (var i = 0, l = 1000; i < l; ) {\n\
          var x = Math.random() * (L + 1);\n\
          x = x | 0;\n\
          if (x >= L) continue;\n\
          data[i] = x;\n\
          i++;\n\
        }\n\
        data_length = l;\n\
\n\
        var code1 = [], code2 = [], code3 = [], code3C = {}, code4 = [], code5C = [], code5 = [];\n\
        for (var i = 0, l = L; i < l; i++) {\n\
          var r = i & M;\n\
\n\
          if (!code3C[r]) {\n\
            code3C[r] = ['case ' + (i & M) + ':', '  switch (i2 | 0) {'];\n\
          }\n\
          code3C[r].push('  case ' + (i & ~M) + ':');\n\
          if (i !== 0) {\n\
            code2.push('} else if (idx === ' + i + ') {');\n\
          } else {\n\
            code2.push('if (idx === ' + i + ') {');\n\
          }\n\
          code1.push('case ' + i + ':');\n\
\n\
          var x = Math.random() * 0xFFFFF;\n\
          x = x | 0;\n\
          dataX[i] = x;\n\
          code5.push('  do_' + i + ',');\n\
          code4.push('  jump_table_gv' + i + ',');\n\
          code3C[r].push('    sum += ' + x + ';', '    continue;');\n\
          code2.push('  sum += ' + x + ';');\n\
          code1.push('  sum += ' + x + ';', '  continue;');\n\
\n\
          var f = new Function('', 'return ' + x + ';');\n\
          // drop these helper functions in global namespace as that is fastest,\n\
          // as shown in other performance tests (compared to having these as\n\
          // sub-level functions internal to `jump_table()` itself!)\n\
          window['jump_table_gv' + i] = f;\n\
          code5C.push(String(f).replace(/anonymous/, 'do_' + i));\n\
        }\n\
\n\
        var k = Object.keys(code3C).map(function (k) { return +k; });\n\
        k.sort();\n\
        k.forEach(function (k) {\n\
          var chunk = code3C[k];\n\
          code3.push.apply(code3, chunk);\n\
          code3.push('  }', '  break;   // not really needed but signals that there is no chance at all of fall-through');\n\
        });\n\
\n\
        code5 = [].concat(code5C, 'const jt = [', code5, [\n\
          '];',\n\
          'var sum = 0;',\n\
          'var d = data;',\n\
          'for (var i = 0, l = data_length; i < l; i++) {',\n\
          '  var idx = d[i];',\n\
          '  sum += jt[idx]();',\n\
          '}',\n\
          'return sum;',\n\
        ]);\n\
        code4 = ['const jt = ['].concat(code4, [\n\
          '];',\n\
          'var sum = 0;',\n\
          'var d = data;',\n\
          'for (var i = 0, l = data_length; i < l; i++) {',\n\
          '  var idx = d[i];',\n\
          '  sum += jt[idx]();',\n\
          '}',\n\
          'return sum;',\n\
        ]);\n\
        code3 = [\n\
          'var sum = 0;',\n\
          'var d = data;',\n\
          'for (var i = 0, l = data_length; i < l; i++) {',\n\
          'var idx = d[i];',\n\
          'var i1 = idx & ' + M + ';',\n\
          'var i2 = idx - i1;',\n\
          'switch (i1) {',\n\
        ].concat(code3, [\n\
          '}',\n\
          '}',\n\
          'return sum;',\n\
        ]);\n\
        code2 = [\n\
          'var sum = 0;',\n\
          'var d = data;',\n\
          'for (var i = 0, l = data_length; i < l; i++) {',\n\
          'var idx = d[i];',\n\
        ].concat(code2, [\n\
          '}',\n\
          '}',\n\
          'return sum;',\n\
        ]);\n\
        code1 = [\n\
          'var sum = 0;',\n\
          'var d = data;',\n\
          'for (var i = 0, l = data_length; i < l; i++) {',\n\
          'var idx = d[i];',\n\
          'switch (idx) {',\n\
        ].concat(code1, [\n\
          '}',\n\
          '}',\n\
          'return sum;',\n\
        ]);\n\
\n\
        switch_case = new Function('', code1.join('\\n'));\n\
        if_elif = new Function('', code2.join('\\n'));\n\
        dual_layer_switch_case = new Function('', code3.join('\\n'));\n\
        jump_table = new Function('', code4.join('\\n'));\n\
        jump_table2 = new Function('', code5.join('\\n'));\n\
\n\
        glob = direct_5(data);\n\
\n\
        window.console && console.log('init:: data set:', data.slice(0, 20), '...');\n\
        window.console && console.log('init:: generated functions:', String(switch_case), String(if_elif), String(dual_layer_switch_case), String(jump_table), String(jump_table2));\n\
      }\n\
\n\
      function assert(rv) {\n\
        if (rv != glob) {\n\
          console.error('test should have produced the number', glob, 'but instead it produced', rv);\n\
          throw new Error('test should have produced the reference number');\n\
        }\n\
      }\n\
\n\
      function direct_5(data) {\n\
        var len = data.length;\n\
\n\
        var sum = 0;\n\
        for (var i = 0; i < len; i++) {\n\
          var idx = data[i];\n\
          sum += dataX[idx];\n\
        }\n\
        return sum;\n\
      }\n\
      ",
  tests: [
    {
      name: 'large `switch`/`case`',
      fn: '\
        assert(switch_case());'
    },
    {
      name: '`if`/`elif` chain',
      fn: '\
        assert(if_elif());'
    },
    {
      name: 'dual layer `switch`/`case`\n\n\
> The large `switch`/`case` has been split into multiple small `switch`/`case` blocks, which are contained within an *outer* `switch`/`case`',
      fn: '\
        assert(dual_layer_switch_case());'
    },
    {
      name: 'jump table',
      fn: '\
        assert(jump_table());'
    },
    {
      name: 'jump table v2 (internal subfunctions)',
      fn: '\
        assert(jump_table2());'
    },
    {
      name: 'direct (shows only overhead in sample code)',
      ranking: false,
      fn: '\
        assert(direct_5(data));'
    },
  ],
  setup: "\
        Benchmark.prototype.setup = function () {\n\
\n\
          // specify the number of inner operations\n\
          //   ( = floating point conversions )\n\
          // that each of our test functions execute\n\
          this.operationsPerRound = data.length;\n\
        };\n\
        ",
  teardown: "\
        Benchmark.prototype.teardown = function () { };\n\
        "
}
